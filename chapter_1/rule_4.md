#### 确定对象被使用前已被初始化

    int x；
    class Point {
        int x, y;
    };
在某些语境下会被初始化（为 0），但其他语境不能保证。

最佳的处理方法是，永远在使用之前进行初始化。

××不要混淆了赋值和初始化××
对象的成员变量的初始化可能发生在进入构造函数本体之前。如果成员变量不是内置类型，那么初始化发生在其 default 构造函数被自动调用之时。但内置类型需要初始化。

在构造函数中对非内置类型初始化时，可以直接调用其构造函数初始化，相比于赋值操作，效率更高。

××针对 static 对象××
函数内的 static 对象称为 local static 对象，其他 static 对象称为 non-local static 对象。
编译单元是指阐述单一目标文件的那些源码。基本上它是单一源码文件加上其所含入的头文件。
如果至少有两个源码文件，每一个内含至少一个 non-local static 对象。如果某个编译单元内的某个 non-local static 对象的初始化使用了另一个编译单元内的某个 non-local static 对象，这个对象可能尚未被初始化。因为在 C++ 中，定义于不同编译单元的 non-local static 对象的初始化次序无明确定义。
解决方法：将每个 non-local static 对象搬到自己的专属函数内，这些函数返回一个 reference 指向它所含的对象。然后用户调用这些函数。C++ 保证，函数内的 local static 对象会在函数被调用期间被初始化。

××总结××
- 为内置型对象进行手工初始化；
- 以 local static 对象替代 non-local static 对象。
